BEGIN 
    InitWindow()
    InitAudioDevice()
    icon ← LoadImage("assets\icon.png")
    SetWindowIcon(icon)
    UnloadImage(icon)

    buttonClickSound ← LoadSound("assets\ButtonClicked.mp3")
    popSound ← LoadSound("assets\Pop.mp3")
    victorySound ← LoadSound("assets\FFVictory.mp3")
    loseSound ← LoadSound("assets\MarioLose/mp3")
    drawSound ← LoadSound("assets\Draw.mp3")
    mainMenuSound ← LoadSound("assets\MainMenu.mp3")
    playSound ← LoadSound("assets\Play.mp3")

    InitSymbols()
    InitTitleWords()

    WHILE (!WindowShouldClose())
        IF (gameState == MENU || gameState == DIFFICULTY_SELECT)
            IF (!IsSoundPlaying(mainMenuSound))
                PlaySound(mainMenuSound)
            ENDIF
            StopSound(playSound)
        ENDIF
        ELSEIF (gameState == GAME)
            IF (!IsSoundPlaying(playSound))
                PlaySound(playSound)
            ENDIF
            StopSound(mainMenuSound)
        ENDIF
        ELSE 
            StopSound(mainMenuSound)
            StopSound(playSound)
        ENDIF

        IF (gameState == MENU || gameState == DIFFICULTY_SELECT)
            UpdateSymbols()
            UpdateTitleWords()
        ENDIF

        IF (gameState == MENU)
            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos = GetMousePosition()

                IF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                    mousePos.y >= SCREEN_HEIGHT/2 + 60 && mousePos.y <= SCREEN_HEIGHT/2 + 100)
                    PlaySound(buttonClickSound)
                    isTwoPlayer ← false
                    gameState ← DIFFICULTY_SELECT
                ENDIF

                ELSEIF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                    mousePos.y >= SCREEN_HEIGHT/2 + 120 && mousePos.y <= SCREEN_HEIGHT/2 + 160)
                    PlaySound(buttonClickSound)
                    isTwoPlayer ← true
                    gameState ← GAME
                    InitGame()
                ENDIF

                ELSEIF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                        mousePos.y >= SCREEN_HEIGHT/2 + 180 && mousePos.y <= SCREEN_HEIGHT/2 + 220)
                        PlaySound(buttonClickSound)
                        BREAK
                ENDIF
            ENDIF
        ENDIF

        ELSEIF (gameState == GAME)
            UpdateGame(buttonClickSound, popSound, victorySound, loseSound, drawSound)
        ENDIF

        ELSEIF (gameState == GAME_OVER)
            UpdateGameOver(buttonClickSound)
        ENDIF

        ELSEIF (gameState == DIFFICULTY_SELECT)

            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos = GetMousePosition()

                IF (mousePos.x >= 20 && mousePos.x <= SCREEN_WIDTH/6 && mousePos.y >= 10 && mousePos.y <= 40)
                    PlaySound(buttonClickSound)
                    gameState ← MENU
                ENDIF

                IF (mousePos.x >= SCREEN_WIDTH/2 - BUTTON_WIDTH/2 && 
                    mousePos.x <= SCREEN_WIDTH/2 + BUTTON_WIDTH/2)

                    IF (mousePos.y >= SCREEN_HEIGHT/2 && mousePos.y <= SCREEN_HEIGHT/2 + BUTTON_HEIGHT)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← EASY
                        gameState ← GAME
                        InitGame()
                    ENDIF

                    ELSEIF (mousePos.y >= SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20 && 
                            mousePos.y <= SCREEN_HEIGHT/2 + BUTTON_HEIGHT * 2 + 20)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← MEDIUM
                        gameState ← GAME
                        InitGame()
                    ENDIF

                    ELSEIF (mousePos.y >= SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2 && 
                            mousePos.y <= SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2 + BUTTON_HEIGHT)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← HARD
                        gameState ← GAME
                        InitGame()
                    ENDIF
                ENDIF
            ENDIF
        ENDIF

        BeginDrawing()
        ClearBackground()

        SWITCH(gameState)
            CASE MENU
                DrawSymbols() 
                DrawTitleWords()
                DrawMenu()
                BREAK 
            CASE DIFFICULTY_SELECT
                DrawSymbols()
                DrawDifficultySelect()
                BREAK 
            CASE GAME
                DrawGame()
                BREAK 
            CASE GAME_OVER
                DrawGame()
                DrawGameOver()
                BREAK 
        ENDSWITCH
        EndDrawing()
    ENDWHILE

    UnloadSound(buttonClickSound)
    UnloadSound(popSound)
    UnloadSound(victorySound)
    UnloadSound(loseSound)
    UnloadSound(drawSound)
    UnloadSound(mainMenuSound)
    UnloadSound(playSound)
    CloseAudioDevice()
    CloseWindow()
END 

FUNCTION InitTitleWords()
    words ← {"Tic", "-", "Tac", "-", "Toe"}
    startX ← SCREEN_WIDTH / 2 - MeasureText("Tic-Tac-Toe", 40) / 2
    startY ← SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20
    int spacing ← 10

    FOR i ← 0 to 4 do
        titleWords[i].word ← words[i]
        titleWords[i].position ← (Vector2){ startX, startY }
        titleWords[i].targetPosition ← (Vector2){ startX, startY - 20 }
        titleWords[i].isJumping ← false
        titleWords[i].jumpSpeed ← JUMP_SPEED
        startX ← startX + MeasureText(words[i], 40) + spacing
    ENDFOR
ENDFUNCTION

FUNCTION UpdateTitleWords()
    currentWord ← 0
    jumpDelay ← 0.0f

    jumpDelay ← jumpDelay + GetFrameTime()
    IF (jumpDelay > JUMP_DELAY)
        IF (!titleWords[currentWord].isJumping)
            titleWords[currentWord].isJumping ← true
            jumpDelay ← 0.0f
        ENDIF
    ENDIF

    FOR i = 0 to 4 do 
        IF (titleWords[i].isJumping)
            titleWords[i].position.y ← titleWords[i].position.y - titleWords[i].jumpSpeed
            
            IF (titleWords[i].position.y <= titleWords[i].targetPosition.y)
                titleWords[i].jumpSpeed ← -titleWords[i].jumpSpeed
            ENDIF

            IF (titleWords[i].position.y >= SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20)
                titleWords[i].position.y ← SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20
                titleWords[i].isJumping ← false
                titleWords[i].jumpSpeed ← JUMP_SPEED
                currentWord ← (currentWord + 1) % 5
            ENDIF
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION DrawTitleWords()
    FOR i = 0 to 4 do
        DrawText(titleWords[i].word, titleWords[i].position.x, titleWords[i].position.y, 40, BLACK)
    ENDFOR
ENDFUNCTION

FUNCTION InitSymbols()
    FOR i = 0 to MAX_SYMBOLS - 1 do
        symbols[i].position ← (Vector2){ GetRandomValue(0, SCREEN_WIDTH), GetRandomValue(-SCREEN_HEIGHT, 0) }
        symbols[i].symbol ← GetRandomValue(0, 1) ? 'X' : 'O'
        symbols[i].rotation ← GetRandomValue(0, 360)
    ENDFOR
ENDFUNCTION

FUNCTION UpdateSymbols()
    FOR i = 0 to MAX_SYMBOLS - 1 do 
        symbols[i].position.y ← symbols[i].position.y + SYMBOL_SPEED
        symbols[i].rotation ← symbols[i].rotation + ROTATION_SPEED
        IF (symbols[i].position.y > SCREEN_HEIGHT)
            symbols[i].position.y ← GetRandomValue(-SCREEN_HEIGHT, 0)
            symbols[i].position.x ← GetRandomValue(0, SCREEN_WIDTH)
            symbols[i].symbol ← GetRandomValue(0, 1) ? 'X' : 'O'
            symbols[i].rotation ← GetRandomValue(0, 360)
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION DrawSymbols()
    for i = 0 tp MAX_SYMBOLS - 1 do
        origin ← {10, 10};  
        DrawTextPro(GetFontDefault(), &symbols[i].symbol, symbols[i].position, origin, symbols[i].rotation, 20, 1, symbols[i].symbol == 'X' ? BLUE : RED)
    ENDFOR
ENDFUNCTION

FUNCTION UpdateGame()
    IF (gameOver)
        RETURN 

    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        IF (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 &&
            mousePos.y >= 10 && mousePos.y <= 40)
            PlaySound(buttonClickSound)
            gameState ← MENU
            RETURN 
        ENDIF
    ENDIF

    IF (currentPlayerTurn == PLAYER_X_TURN)
        IF (HandlePlayerTurn())
            PlaySound()
        ENDIF
    ENDIF

    ELSEIF (currentPlayerTurn == PLAYER_O_TURN)
        IF (isTwoPlayer)
            IF (HandlePlayerTurn()) 
                PlaySound() 
            ENDIF
        ENDIF

        ELSE
            AITurn()
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION HandlePlayerTurn()
    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        row ← (int)(mousePos.y / CELL_SIZE)
        col ← (int)(mousePos.x / CELL_SIZE)

        IF (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE)

            IF (grid[row][col] == EMPTY)
                grid[row][col] ← (currentPlayerTurn == PLAYER_X_TURN) ? PLAYER_X : PLAYER_O

                IF (CheckWin(grid[row][col]))
                    gameOver ← true
                    winner ← grid[row][col]
                    gameState ← GAME_OVER

                    IF (!isTwoPlayer)
                        IF (winner == PLAYER_X)
                            PlaySound(victorySound)
                        ENDIF

                        ELSEIF (winner == PLAYER_O)
                            PlaySound(loseSound)
                        ENDIF
                    ENDIF

                    ELSE
                        PlaySound(victorySound)
                    ENDIF
                ENDIF

                ELSEIF (CheckDraw())
                    gameOver ← true
                    gameState ← GAME_OVER
                    winner ← EMPTY
                    PlaySound(drawSound)
                ENDIF

                ELSE 
                    currentPlayerTurn ← (currentPlayerTurn == PLAYER_X_TURN) ? PLAYER_O_TURN : PLAYER_X_TURN
                ENDIF

                RETURN true
            ENDIF
        ENDIF
    ENDIF
    RETURN false
ENDFUNCTION

FUNCTION load_data(filename, boards, outcomes, total_records)
    file_ptr refToFile → &filename
    OPEN FILE file_ptr
    IF (file_ptr = NULL)
        PRINT "Failed to open file"
    ENDIF

    WHILE (READ FILE *file_ptr)
        line[50] ← *file_ptr
        board[10] ← {line[0] to line[9]}
        outcome[10] ← {line[10] to line[19]}

        boards[total_records] ← board[10]
        outcomes[total_records] ← outcome_index(outcome)
        total_records ← total_records + 1
    ENDWHILE
    CLOSE FILE file_ptr
ENDFUNCTION

FUNCTION split_data(boards, outcomes, total_records, train_boards, train_outcomes, test_boards, test_outcomes, train_size, test_size, ratio)
    train_size refToInt → &train_size
    test_size refToInt → &test_size

    FOR i = (total_records - 1) down to 1 do
        j ← rand() % (i + 1)

        temp_board ← boards[i]
        boards[i] ← boards[j]
        boards[j] ← temp_board

        temp_outcome ← outcomes[i]
        outcomes[i] ← outcomes[j]
        outcomes[j] ← temp_outcome
    ENDFOR

    target_train_size ← ratio * total_records

    FOR i = 0 to total_records do
        IF (*train_sisze < target_train_size)
            train_boards[*train_size] ← boards[i]
            train_outcomes{*train_size} ← outcomes[i]
            *train_size ← *train_size + 1
        ELSE
            test_boards[*test_size] ← boards[i]
            test_outcomes{*test_size} ← outcomes[i]
            *test_size ← *test_size + 1
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION outcome_index(outcome)
    IF (outcome = "positive")
        RETURN POSITIVE
    ELSE
        RETURN NEGATIVE
    ENDIF
ENDFUNCTION

FUNCTION train_NBmodel(model, boards, outcomes, size)
    model refToNaiveBayesModel → &NBmodel

    positive_count ← 0
    negative_count ← 0

    x_counts[NUM_POSITIONS][NUM_OUTCOMES] ← {0}
    o_counts[NUM_POSITIONS][NUM_OUTCOMES] ← {0}
    b_counts[NUM_POSITIONS][NUM_OUTCOMES] ← {0}

    FOR i = 0 to size do
        outcome_idx ← outcomes[i]
        IF (outcome_idx = POSITIVE)
            positive_count ← positive_count + 1
        ELSE
            negative_count ← negative_count + 1
        ENDIF

        FOR j = 0 to NUM_POSITIONS do
            IF (boards[i][j] = 'x')
                x_counts[j][outcome_idx] ← x_counts[j][outcome_idx] + 1
            ELSEIF (boards[i][j] = 'o')
                o_counts[j][outcome_idx] ← o_counts[j][outcome_idx] + 1
            ELSE
                b_counts[j][outcome_idx] ← b_counts[j][outcome_idx] + 1
            ENDIF
        ENDFOR
    ENDFOR

    model→class_probs[POSITIVE] ← positive_count / size
    model→class_probs[NEGATIVE] ← negative_count / size

    FOR i = 0 to NUM_POSITIONS do
        model→ x_probs[i][POSITIVE] ← (x_counts[i][POSITIVE] + 1) / (positive_count + 3)
        model→ x_probs[i][NEGATIVE] ← (x_counts[i][NEGATIVE] + 1) / (negative_count + 3)

        model→ o_probs[i][POSITIVE] ← (o_counts[i][POSITIVE] + 1) / (positive_count + 3)
        model→ o_probs[i][NEGATIVE] ← (o_counts[i][NEGATIVE] + 1) / (negative_count + 3)

        model→ b_probs[i][POSITIVE] ← (b_counts[i][POSITIVE] + 1) / (positive_count + 3)
        model→ b_probs[i][NEGATIVE] ← (b_counts[i][NEGATIVE] + 1) / (negative_count + 3)
    ENDFOR
ENDFUNCTION

FUNCTION save_NBmodel(model, filename)
    model refToNaiveBayesModel → &NBmodel

    file_ptr refToFile → &filename
    OPEN FILE file_ptr
    IF (file_ptr = NULL)
        PRINT "Failed to open file"
    ENDIF

    WRITE "Class Probabilities"
    WRITE "P(Positive):", model→class_probs[POSITIVE]
    WRITE "P(Negative):", model→class_probs[negative]
    
    FOR i = 0 to NUM_POSITIONS do
        WRITE "Position " (i+1)
        WRITE "P(x | Positive):", model→x_probs[i][POSITIVE]
        WRITE "P(x | Negative):", model→x_probs[i][NEGATIVE]
        WRITE "P(o | Positive):", model→o_probs[i][POSITIVE]
        WRITE "P(o | Negative):", model→o_probs[i][NEGATIVE]
        WRITE "P(b | Positive):", model→b_probs[i][POSITIVE]
        WRITE "P(b | Negative):", model→b_probs[i][NEGATIVE]
    ENDFOR

    CLOSE FILE file_ptr

    PRINT "Model weights saved to " filename
ENDFUNCTION

FUNCTION test_NBmodel(filename, mode, type, model, boards, outcomes, size)
    file_ptr refToFile → &filename
    model refToNaiveBayesModel → &NBmodel

    true_positive ← 0
    false_positive ← 0
    true_negative ← 0
    false_negative ← 0
    error_count ← 0

    FOR i = 0 to size do
        predicted_outcome ← predict_outcome(model, boards[i])
        IF (outcomes[i] = POSITIVE && predicted_outcome = POSITIVE)
            true_positive ← true_positive + 1
        ELSEIF (outcomes[i] = POSITIVE && predicted_outcome = NEGATIVE)
            false_negative ← false_negative + 1
            error_count ← error_count + 1
        ELSEIF (outcomes[i] = NEGATIVE && predicted_outcome = NEGATIVE)
            true_negative ← true_negative + 1
        ELSE
            false_positive ← false_positive + 1
            error_count ← error_count + 1
        ENDIF
    ENDFOR

    prob_of_error ← error_count / size * 100

    OPEN FILE file_ptr
    IF (file_ptr = NULL)
        PRINT "Failed to open file"
    ENDIF

    IF (type = "Testing)
        WRITE "\n\n"
    ENDIF

    WRITE "Dataset:", type
    WRITE "Accuracy:", (100 - prob_of_error), (size - error_count), size
    WRITE "Error:", prob_of_error, error_count, size
    WRITE "Confusion Matrix"
    WRITE "True Positive:", true_positive
    WRITE "False Positive:", false_positive
    WRITE "True Negative:", true_negative
    WRITE "False Negative:", false_negative

    CLOSE FILE file_ptr
ENDFUNCTION

FUNCTION calculate_probability(model, board, outcome)
    model refToNaiveBayesModel → &NBmodel

    probability ← model→class_probs[outcome]

    FOR i = 0 to NUM_POSITIONS do
        IF (board[i] = 'x')
            probability ← probability * model→x_probs[i][outcome]
        ELSEIF (board[i] = 'o')
            probability ← probability * model→o_probs[i][outcome]
        ELSE
            probability ← probability * model→b_probs[i][outcome]
        ENDIF
    ENDFOR
    RETURN probability
ENDFUNCTION

FUNCTION predict_outcome(model, board)
    model refToNaiveBayesModel → &NBmodel

    positive_prob ← calculate_probability(model, board, POSITIVE)
    negative_prob ← calculate_probability(model, board, NEGATIVE)

    IF (positive_prob > negative_prob)
        RETURN POSITIVE
    ELSE
        RETURN NEGATIVE
    ENDIF
ENDFUNCTION

FUNCTION predict_move(model, grid[GRID_SIZE][GRID_SIZE], bestRow, bestCol)
    model refToNaiveBayesModel → &NBmodel

    best_move ← -1
    best_prob ← 0.0
    k ← 0

    FOR i = 0 to GRID_SIZE do
        FOR j = 0 to GRID_SIZE do
            IF (grid[i][j] = EMPTY)
                board[k] ← 'b'
            ELSEIF (grid[i][j] = PLAYER_O)
                board[k] ← 'o'
            ELSE
                board[k] ← 'x'
            k ← k + 1
        ENDFOR
    ENDFOR

    FOR i = 0 to NUM_POSITIONS do
        IF (board[i] = 'b')
            temp_board ← board
            temp_board[i] ← 'x'

            positive_prob ← calculate_probability(model, temp_board, POSITIVE)

            IF (positive_prob > best_prob)
                best_prob ← positive_prob
                best_move ← i
            ENDIF
        ENDIF
    ENDFOR

    divide(best_move, 3, bestRow, bestCol)

    RETURN 0
ENDFUNCTION

FUNCTION divide(dividend, divisor, quo, rem)
    quo refToInt → &quo
    rem refToInt → &rem

    *quo ← dividend / divisor
    *rem ← dividend % divisor
ENDFUNCTION