/*********************/
/* main.c file       */
/*********************/                    
BEGIN 
    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "Tic-Tac-Toe")
    InitAudioDevice()
    icon ← LoadImage("assets\icon.png")
    SetWindowIcon(icon)
    UnloadImage(icon)

    buttonClickSound ← LoadSound("assets\ButtonClicked.mp3")
    popSound ← LoadSound("assets\Pop.mp3")
    victorySound ← LoadSound("assets\FFVictory.mp3")
    loseSound ← LoadSound("assets\MarioLose/mp3")
    drawSound ← LoadSound("assets\Draw.mp3")
    mainMenuSound ← LoadSound("assets\MainMenu.mp3")
    playSound ← LoadSound("assets\Play.mp3")

    SetSoundVolume(buttonClickSound, 0.4f)
    SetSoundVolume(popSound, 0.4f)
    SetSoundVolume(victorySound, 0.4f)
    SetSoundVolume(loseSound, 0.4f)
    SetSoundVolume(drawSound, 0.4f)
    SetSoundVolume(mainMenuSound, 0.4f)
    SetSoundVolume(playSound, 0.4f)

    InitSymbols()
    InitTitleWords()
    InitConfetti()

    boards[1000][NUM_POSITIONS + 1] ← {0}

    total_records ← 0

    load_data("tic-tac-toe.data", boards, outcomes, &total_records)

    train_size ← 0
    test_size ← 0

    split_data(boards, outcomes, total_records, train_boards, train_outcomes, test_boards, test_outcomes, &train_size, &test_size, RATIO)

    train_NBmodel(&NBmodel, train_boards, train_outcomes, train_size)

    save_NBmodel(&NBmodel, "NBmodel/NBmodel_weights.txt")

    mode ← "w"
    type ← "Training"
    test_NBmodel("NBmodel/NBmodel_confusion_matrix.txt", mode, type, &NBmodel, train_boards, train_outcomes, train_size)
    
    strcpy(mode, "a")
    strcpy(type, "Testing")
    test_NBmodel("NBmodel/NBmodel_confusion_matrix.txt", mode, type, &NBmodel, test_boards, test_outcomes, test_size)

    growth_Tree(&TDmodel)

    WHILE (!WindowShouldClose())
        IF (gameState == MENU || gameState == DIFFICULTY_SELECT || gameState == MODEL_SELECT)
            IF (!IsSoundPlaying(mainMenuSound))
                PlaySound(mainMenuSound)
            ENDIF
            StopSound(playSound)
        ELSEIF (gameState == GAME)
            IF (!IsSoundPlaying(playSound))
                PlaySound(playSound)
            ENDIF
            StopSound(mainMenuSound)
        ELSE 
            StopSound(mainMenuSound)
            StopSound(playSound)
        ENDIF

        IF (gameState == MENU || gameState == DIFFICULTY_SELECT || gameState == MODEL_SELECT)
            UpdateSymbols()
            UpdateTitleWords()
        ENDIF

        IF (gameState == MENU)
            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos ← GetMousePosition()

                IF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                    mousePos.y >= SCREEN_HEIGHT/2 + 60 && mousePos.y <= SCREEN_HEIGHT/2 + 100)
                    PlaySound(buttonClickSound)
                    isTwoPlayer ← false
                    gameState ← DIFFICULTY_SELECT
                ELSEIF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                    mousePos.y >= SCREEN_HEIGHT/2 + 120 && mousePos.y <= SCREEN_HEIGHT/2 + 160)
                    PlaySound(buttonClickSound)
                    isTwoPlayer ← true
                    gameState ← GAME
                    InitGame()
                ELSEIF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                        mousePos.y >= SCREEN_HEIGHT/2 + 180 && mousePos.y <= SCREEN_HEIGHT/2 + 220)
                        PlaySound(buttonClickSound)
                        BREAK
                ENDIF
            ENDIF
        ELSEIF (gameState == GAME)
            UpdateGame(buttonClickSound, popSound, victorySound, loseSound, drawSound)
        ELSEIF (gameState == GAME_OVER)
            UpdateGameOver(buttonClickSound)
        ELSEIF (gameState == DIFFICULTY_SELECT)

            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos ← GetMousePosition()

                IF (mousePos.x >= 20 && mousePos.x <= SCREEN_WIDTH/6 && mousePos.y >= 10 && mousePos.y <= 40)
                    PlaySound(buttonClickSound)
                    gameState ← MENU
                ENDIF

                IF (mousePos.x >= SCREEN_WIDTH/2 - BUTTON_WIDTH/2 && 
                    mousePos.x <= SCREEN_WIDTH/2 + BUTTON_WIDTH/2)

                    IF (mousePos.y >= SCREEN_HEIGHT/2 && mousePos.y <= SCREEN_HEIGHT/2 + BUTTON_HEIGHT)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← EASY
                        gameState ← MODEL_SELECT
                        InitGame()
                    ELSEIF (mousePos.y >= SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20 && 
                            mousePos.y <= SCREEN_HEIGHT/2 + BUTTON_HEIGHT * 2 + 20)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← MEDIUM
                        gameState ← GAME
                        InitGame()
                    ELSEIF (mousePos.y >= SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2 && 
                            mousePos.y <= SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2 + BUTTON_HEIGHT)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← HARD
                        gameState ← GAME
                        InitGame()
                    ENDIF
                ENDIF
            ENDIF
        ELSEIF (gameState == MODEL_SELECT)
            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos ← GetMousePosition()

                IF (mousePos.x >= 20 && mousePos.x <= SCREEN_WIDTH/6 && mousePos.y >= 10 && mousePos.y <= 40)
                    PlaySound(buttonClickSound)
                    gameState ← DIFFICULTY_SELECT
                ENDIF

                nbBtn = SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
                        SCREEN_HEIGHT/2,
                        BUTTON_WIDTH,
                        BUTTON_HEIGHT

                dtBtn = SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
                        SCREEN_HEIGHT/2,
                        BUTTON_WIDTH,
                        BUTTON_HEIGHT

                IF (CheckCollisionPointRec(mousePos, nbBtn))
                    PlaySound(buttonClickSound)
                    currentModel ← NAIVE_BAYES
                    gameState ← GAME
                    InitGame()
                ELSEIF (CheckCollisionPointRec(mousePos, dtBtn))
                    PlaySound(buttonClickSound)
                    currentModel ← DECISION_TREE
                    gameState ← GAME
                    InitGame()
                ENDIF
            ENDIF
        ENDIF

        BeginDrawing()
        ClearBackground(RAYWHITE)

        SWITCH(gameState)
            CASE MENU
                DrawSymbols() 
                DrawTitleWords()
                DrawMenu()
                BREAK 
            CASE DIFFICULTY_SELECT
                DrawSymbols()
                DrawDifficultySelect()
                BREAK 
            CASE MODEL_SELECT
                DrawSymbols()
                DrawModelSelect()
                BREAK
            CASE GAME
                DrawGame()
                BREAK 
            CASE GAME_OVER
                DrawGame()
                DrawGameOver()
                IF (showPartyAnimation == true)
                    UpdateConfetti()
                    DrawConfetti()
                ENDIF
                BREAK 
        ENDSWITCH
        EndDrawing()
    ENDWHILE

    UnloadSound(buttonClickSound)
    UnloadSound(popSound)
    UnloadSound(victorySound)
    UnloadSound(loseSound)
    UnloadSound(drawSound)
    UnloadSound(mainMenuSound)
    UnloadSound(playSound)
    CloseAudioDevice()
    CloseWindow()
    return 0
END 

FUNCTION GetCurrentModeStats()
    IF (currentDifficulty == EASY)
        IF (currentModel == NAIVE_BAYES)
            RETURN &naiveBayesStats
        ELSE
            RETURN &decisionTreeStats
        ENDIF
    ELSE
        IF (currentDifficulty == MEDIUM)
            RETURN &mediumStats
        ELSE
            RETURN &hardStats
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION RandomizeStartingPlayer()
    IF (GetRandomValue(0, 1) == 0)
        currentPlayerTurn ← PLAYER_X_TURN
    ELSE
        currentPlayerTurn ← PLAYER_O_TURN
    ENDIF
ENDFUNCTION


/*********************/
/* Init.c file       */
/*********************/
FUNCTION InitTitleWords()
    words ← {"Tic", "-", "Tac", "-", "Toe"}
    startX ← SCREEN_WIDTH / 2 - MeasureText("Tic-Tac-Toe", 40) / 2
    startY ← SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20
    int spacing ← 10

    FOR i ← 0 to 4 do
        titleWords[i].word ← words[i]
        titleWords[i].position ← (Vector2){ startX, startY }
        titleWords[i].targetPosition ← (Vector2){ startX, startY - 20 }
        titleWords[i].isJumping ← false
        titleWords[i].jumpSpeed ← JUMP_SPEED
        startX ← startX + MeasureText(words[i], 40) + spacing
    ENDFOR
ENDFUNCTION

FUNCTION InitSymbols()
    FOR i = 0 to MAX_SYMBOLS - 1 do
        symbols[i].position ← (Vector2){ GetRandomValue(0, SCREEN_WIDTH), GetRandomValue(-SCREEN_HEIGHT, 0) }
        symbols[i].symbol ← GetRandomValue(0, 1) ? 'X' : 'O'
        symbols[i].rotation ← GetRandomValue(0, 360)
    ENDFOR
ENDFUNCTION

FUNCTION InitConfetti()
    FOR i = 0 to MAX_CONFETTI - 1 do
        confetti[i].position ← (Vector2){ SCREEN_WIDTH - GetRandomValue(30, 70), SCREEN_HEIGHT - GetRandomValue(30, 70)}
        angle ← GetRandomValue(160, 280) * DEG2RAD
        speed ← GetRandomValue(600, 1200)/100.0f
        confetti[i].velocity ← (Vector2){ cos(angle) * speed, sin(angle) * speed }
        SWITCH(GetRandomValue(0, 4))
            CASE 0:
                confetti[i].color ← RED
                BREAK
            CASE 1:
                confetti[i].color ← GREEN
                BREAK
            CASE 2:
                confetti[i].color ← BLUE
                BREAK
            CASE 3:
                confetti[i].color ← YELLOW
                BREAK
            CASE 4:
                confetti[i].color ← Pink
                BREAK
        ENDSWITCH
        confetti[i].size ← GetRandomValue(2, 4)
        confetti[i].active ← true
        confetti[i].alpha ← 1.0f
        confetti[i].lifetime ← GetRandomValue(150, 200)/100.0f
    ENDFOR
ENDFUNCTION

FUNCTION InitGame()
    hint.hintCountO ← 0
    hint.hintCountX ← 0
    showPartyAnimation ← false
    StopSound(victorySound)
    StopSound(loseSound)
    StopSound(drawSound)
    memset(grid, EMPTY, sizeof(grid))
    gameOver ← false
    winner ← EMPTY
    RandomizeStartingPlayer()
    FOR i = 0 to 2 do
        winningCells[i][0] ← -1
        winningCells[i][1] ← -1
ENDFUNCTION


/*********************/
/* Update.c file     */
/*********************/
FUNCTION UpdateTitleWords()
    currentWord ← 0
    jumpDelay ← 0.0f

    jumpDelay ← jumpDelay + GetFrameTime()
    IF (jumpDelay > JUMP_DELAY)
        IF (!titleWords[currentWord].isJumping)
            titleWords[currentWord].isJumping ← true
            jumpDelay ← 0.0f
        ENDIF
    ENDIF

    FOR i = 0 to 4 do 
        IF (titleWords[i].isJumping)
            titleWords[i].position.y ← titleWords[i].position.y - titleWords[i].jumpSpeed
            
            IF (titleWords[i].position.y <= titleWords[i].targetPosition.y)
                titleWords[i].jumpSpeed ← -titleWords[i].jumpSpeed
            ENDIF

            IF (titleWords[i].position.y >= SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20)
                titleWords[i].position.y ← SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20
                titleWords[i].isJumping ← false
                titleWords[i].jumpSpeed ← JUMP_SPEED
                currentWord ← (currentWord + 1) % 5
            ENDIF
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION UpdateSymbols()
    FOR i = 0 to MAX_SYMBOLS - 1 do 
        symbols[i].position.y ← symbols[i].position.y + SYMBOL_SPEED
        symbols[i].rotation ← symbols[i].rotation + ROTATION_SPEED
        IF (symbols[i].position.y > SCREEN_HEIGHT)
            symbols[i].position.y ← GetRandomValue(-SCREEN_HEIGHT, 0)
            symbols[i].position.x ← GetRandomValue(0, SCREEN_WIDTH)
            symbols[i].symbol ← IF GetRandomValue(0, 1) ? 'X' : 'O'
            symbols[i].rotation ← GetRandomValue(0, 360)
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION UpdateConfetti()
    FOR i = 0 to MAX_CONFETTI - 1 do
        IF (confetti[i].active)
            allInactive ← false
            confetti[i].velocity.x = confetti[i].velocity.x * 0.99f
            confetti[i].velocity.y = confetti[i].velocity.y * 0.99f            
            
            confetti[i].position.x ← confetti[i].position.x + confetti[i].velocity.x * 0.6f
            confetti[i].position.y ← confetti[i].position.y + confetti[i].velocity.y * 0.6f
            
            confetti[i].velocity.y ← confetti[i].velocity.y + 0.02f
            
            confetti[i].velocity.x ← confetti[i].velocity.x + GetRandomValue(-20, 20) / 100.0f
            confetti[i].velocity.y ← confetti[i].velocity.y + GetRandomValue(-20, 20) / 100.0f

            confetti[i].alpha ← confetti[i].alpha - 0.02f
            confetti[i].lifetime ← confetti[i].lifetime - 0.02f

            IF (confetti[i].alpha <= 0 || 
                confetti[i].lifetime <= 0 ||
                confetti[i].position.y > SCREEN_HEIGHT + 50 ||
                confetti[i].position.x < -50 ||
                confetti[i].position.x > SCREEN_WIDTH + 50)
                    confetti[i].active ← false
            ENDIF
        ENDIF
    ENDFOR
    IF (allInactive)
        showPartyAnimation ← false
    ENDIF
ENDFUNCTION

FUNCTION UpdateGame(buttonClickSound, popSound, victorySound, loseSound, drawSound, *model, *TDmodel)
    IF (gameOver) return 
    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        IF (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 && mousePos.y >= 10 && mousePos.y <= 40)
            PlaySound(buttonClickSound)
            gameState ← MENU
            RETURN 
        ENDIF
    ENDIF
    IF (currentPlayerTurn == PLAYER_X_TURN)
        IF (HandlePlayerTurn(popSound, victorySound, loseSound, drawSound))
            PlaySound(popSound)
        ENDIF
    ELSEIF (currentPlayerTurn == PLAYER_O_TURN)
        IF (isTwoPlayer)
            IF (HandlePlayerTurn(popSound, victorySound, loseSound, drawSound)) 
                PlaySound(popSound) 
            ENDIF
        ELSE
            SWITCH(currentDifficulty)
                CASE EASY
                    IF (currentModel == NAIVE_BAYES)
                        AITurn(victorySound, loseSound, drawSound, model)
                    ELSE
                        AITurnDecisionTree(victorySound, loseSound, drawSound, TDmodel)
                    ENDIF
                    BREAK
                CASE MEDIUM
                    AITurn(victorySound, loseSound, drawSound, model)
                    BREAK
                CASE HARD
                    AITurn(victorySound, loseSound, drawSound, model)
                    BREAK
            ENDSWITCH
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION UpdateGameOver(buttonClickSound)
    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        retryBtn ← {
            SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
            SCREEN_HEIGHT/2 + 40,
            BUTTON_WIDTH,
            BUTTON_HEIGHT
        }
        menuBtn ← {
            SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
            SCREEN_HEIGHT/2 + 100,
            BUTTON_WIDTH,
            BUTTON_HEIGHT
        }
        IF (CheckCollisionPointRec(mousePos, menuBtn))
            PlaySound(buttonClickSound)
            gameState ← MENU
            InitGame()
        ELSEIF (CheckCollisionPointRec(mousePos, retryBtn))
            PlaySound(buttonClickSound)
            gameState ← GAME
            InitGame()
        ENDIF
    ENDIF
ENDFUNCTION


/*********************/
/* Draw.c file       */
/*********************/
FUNCTION DrawConfetti()
    FOR i = 0 to MAX_CONFETTI - 1 do
        IF (confetti[i].active)
            particleColor ← confetti[i].color
            particleColor.a ← confetti[i].alpha*255
            direction ← { -confetti[i].velocity.x * 0.15f, -confetti[i].velocity.y * 0.15f }
            DrawCircle(confetti[i].position.x, confetti[i].position.y, confetti[i].size, particleColor)
            FOR trail = 0 to 7 do
                trailAlpha ← confetti[i].alpha * (1.0f - (trail * 0.14f))
                trailPos ← { confetti[i].position.x + direction.x * trail, confetti[i].position.y + direction.y * trail }
                DrawCircle(trailPos.x, trailPos.y, confetti[i].size * (1.0f - (trail * 0.12f)), ColorAlpha(particleColor, trailAlpha * 255))
            ENDFOR
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION DrawTitleWords()
    FOR i = 0 to 4 do
        DrawText(titleWords[i].word, titleWords[i].position.x, titleWords[i].position.y, 40, BLACK)
    ENDFOR
ENDFUNCTION

FUNCTION DrawSymbols()
    FOR i = 0 tp MAX_SYMBOLS - 1 do
        origin ← {10, 10} 
        DrawTextPro(GetFontDefault(), &symbols[i].symbol, symbols[i].position, origin, symbols[i].rotation, 20, 1, symbols[i].symbol == 'X' ? BLUE : RED)
    ENDFOR
ENDFUNCTION

FUNCTION DrawGame()
    isHintHovered ← false
    mousePos ← GetMousePosition()
    
    FOR i = 0 to GRID_SIZE - 1 do
        FOR j = 0 to GRID_SIZE - 1 do
            cell ← {(j * CELL_SIZE), (i * CELL_SIZE), CELL_SIZE, CELL_SIZE}
            isWinningCell ← false
            IF (gameOver && winner != EMPTY)
                FOR k = 0 to 2 do  
                    IF (winningCells[k][0] == i && winningCells[k][1] == j)
                        isWinningCell ← true
                        BREAK
                    ENDIF
                ENDFOR
            ENDIF

            isHovered ← !gameOver && grid[i][j] == EMPTY && CheckCollisionPointRec(mousePos, cell)

            IF (isWinningCell)
                IF (!isTwoPlayer && winner == PLAYER_O)
                    cellColor ← (Color){255, 200, 200, 255}
                ELSE
                    cellColor ← (Color){144, 238, 144, 255}
                ENDIF
            ELSE
                cellColor ← isHovered ? DARKGRAY : LIGHTGRAY
            ENDIF

            DrawRectangleRec(cell, cellColor)

            IF (grid[i][j] == PLAYER_X)
                text ← "X"
                fontSize ← 100
                textWidth ← MeasureText(text, fontSize)
                textHeight ← fontSize * 0.75f
                textX ← cell.x + (CELL_SIZE - textWidth) / 2
                textY ← cell.y + (CELL_SIZE - textHeight) / 2
                DrawText(text, textX, textY, fontSize, BLUE)
            ELSEIF (grid[i][j] == PLAYER_O)
                text ← "O"
                fontSize ← 100
                textWidth ← MeasureText(text, fontSize)
                textHeight ← fontSize * 0.75f
                textX ← cell.x + (CELL_SIZE - textWidth) / 2
                textY ← cell.y + (CELL_SIZE - textHeight) / 2
                DrawText(text, textX, textY, fontSize, RED)
            ENDIF
        ENDFOR
    ENDFOR

    FOR int = 1 to GRID_SIZE - 1 do 
        DrawLine(i * CELL_SIZE, 0, i * CELL_SIZE, SCREEN_HEIGHT, BLACK)
        DrawLine(0, i * CELL_SIZE, SCREEN_WIDTH, i * CELL_SIZE, BLACK)
    ENDFOR

    hintBtn ← {SCREEN_WIDTH - 80, 10, 70, 30}
    *hintText ← "Hint: "
    snprintf(hintTextFinal, sizeof(hintTextFinal), "%s%d", hintText, (2-hint.hintCountX))
    IF (currentPlayerTurn == PLAYER_X_TURN)
        IF (hint.hintCountX < 2)
            isHintHovered ← (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 && mousePos.y >= 10 && mousePos.y <= 40)
            DrawButton(hintBtn, hintTextFinal, 20, !gameOver && isHintHovered)
        ELSE    
            DrawButton(hintBtn, hintTextFinal, 20, !gameOver && false)
        ENDIF
    ENDIF
    
    snprintf(hintTextFinal, sizeof(hintTextFinal), "%s%d", hintText, (2-hint.hintCountO))
    IF (currentPlayerTurn == PLAYER_O_TURN)
        IF (hint.hintCountO < 2)
            isHintHovered ← (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 && mousePos.y >= 10 && mousePos.y <= 40)
            DrawButton(hintBtn, hintTextFinal, 20, !gameOver && isHintHovered)
        ELSE    
            DrawButton(hintBtn, hintTextFinal, 20, !gameOver && false)
        ENDIF
    ENDIF

    quitBtn ← {SCREEN_WIDTH - 80, 10, 70, 30}
    DrawButton(quitBtn, "Quit", 20, !gameOver && isQuitHovered)

    IF (!gameOver && isQuitHovered)
        SetMouseCursor(MOUSE_CURSOR_POINTING_HAND)
    ELSEIF (!gameOver && isHintHovered)
        SetMouseCursor(MOUSE_CURSOR_POINTING_HAND)
    ELSEIF (!gameOver)
        SetMouseCursor(MOUSE_CURSOR_DEFAULT)
    ENDIF

    IF (!gameOver)
        IF (!isTwoPlayer)
            currentStats ← GetCurrentModeStats()

            PRINT(statsText, "Player: %d | AI: %d | Draws: %d", 
                    currentStats→playerWins, 
                    currentStats→aiWins, 
                    currentStats→draws)
            
            DrawText(statsText, SCREEN_WIDTH/2 - MeasureText(statsText, 20)/2, 10, 20, BLACK)
        ENDIF

        yPos ← isTwoPlayer ? 20 : 40
        IF (currentPlayerTurn == PLAYER_X_TURN)
            turnText ← isTwoPlayer ? "Player X's Turn" : "Your Turn";
            DrawText(turnText, SCREEN_WIDTH/2 - MeasureText(turnText, 30)/2, yPos, 30, BLUE)
        ELSE
            turnText ← isTwoPlayer ? "Player O's Turn" : "AI's Turn";
            DrawText(turnText, SCREEN_WIDTH/2 - MeasureText(turnText, 30)/2, yPos, 30, RED)
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION DrawMenu()
    titleFontSize ← 40
    buttonFontSize ← 20 
    cellSize ← 50
    gridWidth ← TITLE_GRID_SIZE * cellSize
    gridHeight ← TITLE_GRID_SIZE * cellSize
    startX ← SCREEN_WIDTH/2 - gridWidth/2
    startY ← SCREEN_HEIGHT/5

    FOR i = 0 to TITLE_GRID_SIZE - 1 do
        FOR j = 0 to TITLE_GRID_SIZE - 1 do
            cell = {
                startX + j * cellSize,
                startY + i * cellSize,
                cellSize,
                cellSize
            }
            DrawRectangleLinesEx(cell, 2, BLACK)

            IF (!titleSymbols[i][j].active && GetRandomValue(0, 100) < 2)
                titleSymbols[i][j].symbol ← GetRandomValue(0, 1) ? 'X' : 'O'
                titleSymbols[i][j].alpha ← 0
                titleSymbols[i][j].active ← true
            ENDIF

            IF (titleSymbols[i][j].active)
                titleSymbols[i][j].alpha ← titleSymbols[i][j].alpha + GetFrameTime() * 2
                IF (titleSymbols[i][j].alpha > 1.0f) 
                    titleSymbols[i][j].alpha ← 0
                    titleSymbols[i][j].active ← false
                ENDIF

                symbolColor ← titleSymbols[i][j].symbol == 'X' ? BLUE : RED
                symbolColor.a ← (titleSymbols[i][j].alpha * 255)

                textPos ← {
                    cell.x + (cellSize - MeasureText(&titleSymbols[i][j].symbol, 40))/2,
                    cell.y + (cellSize - 40)/2
                }
                DrawText(&titleSymbols[i][j].symbol, textPos.x, textPos.y, 40, symbolColor)
            ENDIF
        ENDFOR
    ENDFOR

    singlePlayerBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    twoPlayerBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    exitBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 3,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    singlePlayerHover ← false
    twoPlayerHover ← false
    exitHover ← false
    HandleButtonHover(singlePlayerBtn, "Single Player", buttonFontSize, &singlePlayerHover)
    HandleButtonHover(twoPlayerBtn, "Two Players", buttonFontSize, &twoPlayerHover)
    HandleButtonHover(exitBtn, "Exit", buttonFontSize, &exitHover)    
    SetMouseCursor((singlePlayerHover || twoPlayerHover || exitHover) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION DrawGameOver()
    titleFontSize ← 40
    buttonFontSize ← 20
    DrawRectangle(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, (Color){0, 0, 0, 100})

    IF (winner == PLAYER_X)
        resultText ← isTwoPlayer ? "Player X Wins!" : "You win!"
        resultColor ← BLUE

    ELSEIF (winner == PLAYER_O)
        resultText ← isTwoPlayer ? "Player O Wins!" : "You lose!"
        resultColor ← RED

    ELSE 
        resultText ← "It's a Draw!"
        resultColor ← DARKGRAY
    ENDIF

    textWidth ← MeasureText(resultText, titleFontSize)
    DrawRectangle(
        SCREEN_WIDTH/2 - textWidth/2 - 10,
        SCREEN_HEIGHT/3 - 10,
        textWidth + 20,
        titleFontSize + 20,
        WHITE
        )
    DrawText(
        resultText, 
        SCREEN_WIDTH/2 - textWidth/2,
        SCREEN_HEIGHT/3,
        titleFontSize,
        resultColor
        )
    retryBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + 40, 
        BUTTON_WIDTH,
        BUTTON_HEIGHT
        }
    menuBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + 100, 
        BUTTON_WIDTH,
        BUTTON_HEIGHT
        }
    mousePos ← GetMousePosition()
    isHoveringMenu ← CheckCollisionPointRec(mousePos, menuBtn)
    isHoveringRetry ← CheckCollisionPointRec(mousePos, retryBtn)
    DrawButton(retryBtn, "Retry", buttonFontSize, isHoveringRetry)
    DrawButton(menuBtn, "Back to Menu", buttonFontSize, isHoveringMenu)
    SetMouseCursor((isHoveringMenu || isHoveringRetry) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION DrawButton(bounds, *text, fontSize, isHovered)
    vibrationBounds ← bounds

    IF (isHovered)
        buttonVibrationOffset ← sinf(GetTime() * vibrationSpeed) * vibrationAmount
        vibrationBounds.x ← vibrationBounds.x + buttonVibrationOffset
    ENDIF

    DrawRectangleRec(vibrationBounds, isHovered ? GRAY : LIGHTGRAY)
    DrawRectangleLinesEx(vibrationBounds, 2, BLACK)
    DrawText(
        text,
        vibrationBounds.x + (vibrationBounds.width - MeasureText(text, fontSize))/2, 
        vibrationBounds.y + (vibrationBounds.height - fontSize)/2, 
        fontSize,
        BLACK
    )
ENDFUNCTION

FUNCTION DrawDifficultySelect()
    titleFontSize ← 40
    buttonFontSize ← 20 
    title ← "Select Difficulty"
    DrawText(
        title, 
        SCREEN_WIDTH/2 - MeasureText(title, titleFontSize)/2, 
        SCREEN_HEIGHT/3,
        titleFontSize,
        BLACK
        )
    
    easyBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    mediumBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    hardBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    backBtn ← {
        20,                
        10,                 
        SCREEN_WIDTH/6,    
        30                 
    }

    easyHover ← false
    mediumHover ← false
    hardHover ← false
    backHover ← false
    HandleButtonHover(easyBtn, "Easy", buttonFontSize, &easyHover)
    HandleButtonHover(mediumBtn, "Medium", buttonFontSize, &mediumHover)
    HandleButtonHover(hardBtn, "Hard", buttonFontSize, &hardHover)
    HandleButtonHover(backBtn, "Back", buttonFontSize, &backHover)    
    SetMouseCursor((easyHover || mediumHover || hardHover || backHover) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION DrawModelSelect()
    title ← "Select AI Model"
    DrawText(
        SCREEN_WIDTH/2 - MeasureText(title, 40)/2,
        SCREEN_HEIGHT/3,
        40,
        BLACK
    )
    nbBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }
    dtBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }
    backBtn ← {
        20,                
        10,                 
        SCREEN_WIDTH/6,    
        30                 
    }
    nbHover ← false
    dtHover ← false
    backHover ← false
    HandleButtonHover(nbBtn, "Naive Bayes", 20, &nbHover)
    HandleButtonHover(dtBtn, "Decision Tree", 20, &dtHover)
    HandleButtonHover(backBtn, "Back", 20, &backHover)
    SetMouseCursor((nbHover || dtHover || backHover) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION


/*********************/
/* Handle.c file     */
/*********************/
FUNCTION HandleButtonHover(button, *text, fontSize, *isHovered)
    mousePos ← GetMousePosition()
    *isHintHovered ← CheckCollisionPointRec(mousePos, button)
    DrawButton(button, text, fontSize, *isHovered)
    return *isHintHovered
ENDFUNCTION

FUNCTION HandlePlayerTurn(popSound, victorySound, loseSound, drawSound)
    clearHint()
    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        row ← (int)(mousePos.y / CELL_SIZE)
        col ← (int)(mousePos.x / CELL_SIZE)
        IF (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 
        && mousePos.y >= 10 && mousePos.y <= 40 && (hint.hintCountX < 2 || hint.hintCountO <2))
            IF (currentPlayerTurn == PLAYER_X_TURN && hint.hintCountX < 2)
                PlaySound(buttonClickSound)
                hint.hintCountX ← hint.hintCountX + 1
                getHint()
                row ← hint.row
                col ← hint.col
            ELSEIF (currentPlayerTurn == PLAYER_O_TURN && hint.hintCountO <2)
                PlaySound(buttonClickSound)
                hint.hintCountO ← hint.hintCountO + 1
                getHint()
                row = hint.row
                row = hint.col
            ELSE
                return false
            ENDIF
        ENDIF
        currentStats ← GetCurrentModeStats()
        IF (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE)
            IF (grid[row][col] == EMPTY)
                grid[row][col] ← (currentPlayerTurn == PLAYER_X_TURN) ? PLAYER_X : PLAYER_O
                IF (CheckWin(grid[row][col]))
                    gameOver ← true
                    winner ← grid[row][col]
                    gameState ← GAME_OVER

                    IF (isTwoPlayer)
                        showPartyAnimation ← true
                        InitConfetti()
                        PlaySound(victorySound)
                    ELSEIF (!isTwoPlayer && winner == PLAYER_X)
                        showPartyAnimation ← true
                        InitConfetti()
                        currentStats→playerWins ← currentStats→playerWins + 1
                        currentStats→totalGames ← currentStats→totalGames + 1
                        PlaySound(victorySound)
                    ELSE
                        showPartyAnimation ← false
                        currentStats→aiWins ← currentStats→aiWins + 1
                        currentStats→totalGames ← currentStats→totalGames + 1
                        PlaySound(loseSound)
                    ENDIF

                ELSEIF (CheckDraw())
                    gameOver ← true
                    gameState ← GAME_OVER
                    winner ← EMPTY
                    currentStats→draws ← currentStats→draws + 1
                    currentStats→totalGames ← currentStats→totalGames + 1
                    PlaySound(drawSound)

                ELSE 
                    currentPlayerTurn ← (currentPlayerTurn == PLAYER_X_TURN) ? PLAYER_O_TURN : PLAYER_X_TURN
                ENDIF

                RETURN true
            ENDIF
        ENDIF
    ENDIF
    RETURN false
ENDFUNCTION


/*********************/
/* AI.c file         */
/*********************/
FUNCTION AITurn(victorySound, loseSound, drawSound, *model)
    bestScore ← -1000
    bestRow ← -1
    bestCol ← -1
    IF (currentDifficulty == EASY)
        IF (currentModel == NAIVE_BAYES)
            predict_move(model, grid, &bestRow, &bestCol)
        ELSE
            AITurnDecisionTree()
        ENDIF

    ELSEIF (currentDifficulty == MEDIUM)
        depthLimit ← 4
        FOR i = 0 to GRID_SIZE - 1 do
            FOR j = 0 to GRID_SIZE - 1 do
                IF (grid[i][j] == EMPTY)
                    grid[i][j] ← PLAYER_O
                    score ← Minimax(grid, false, 0, depthLimit, -1000, 1000)
                    grid[i][j] ← EMPTY

                    IF (score > bestScore)
                        bestScore ← score
                        bestRow ← i 
                        bestCol ← j 
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR

    ELSEIF (currentDifficulty == HARD)
        depthLimit ← 9
        FOR i = 0 to GRID_SIZE - 1 do
            FOR j = 0 to GRID_SIZE - 1 do
                IF (grid[i][j] == EMPTY)
                    grid[i][j] ← PLAYER_O
                    score ← Minimax(grid, false, 0, depthLimit, -1000, 1000)
                    grid[i][j] ← EMPTY

                    IF (score > bestScore)
                        bestScore ← score
                        bestRow ← i 
                        bestCol ← j 
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR
    ENDIF

    IF (bestRow != -1 && bestCol != -1)
        grid[bestRow][bestCol] ← PLAYER_O
    ENDIF

    currentStats ← GetCurrentModeStats()

    IF (CheckWin(PLAYER_O))
        gameOver ← true
        winner ← PLAYER_O
        gameState ← GAME_OVER
        currentStats→aiWins ← currentStats→aiWins + 1           
        currentStats→totalGames ← currentStats→totalGames+ 1  
        IF (!isTwoPlayer)
            PlaySound(loseSound)
        ELSE
            PlaySound(victorySound)
        ENDIF
    ELSEIF (CheckDraw())
        gameOver ← true
        gameState ← GAME_OVER
        winner ← EMPTY
        currentStats→draws ← currentStats→draws + 1           
        currentStats→totalGames ← currentStats→totalGames+ 1  
        PlaySound(drawSound)
    ELSE
        currentPlayerTurn ← PLAYER_X_TURN
    ENDIF
ENDFUNCTION

FUNCTION AITurnDecisionTree(victorySound, loseSound, drawSound, *TDmodel)
    bestScore ← -1000              
    bestRow ← -1                   
    bestCol ← -1      
    best_prob ← 0.0            
    board ← EMPTY 2D ARRAY        

    // Convert the grid into a format suitable for the decision tree
    FOR i = 0 to 2 do
        FOR j = 0 to 2 do
            IF grid[i][j] == EMPTY
                board[i][j] ← 'b'  
            ELSEIF grid[i][j] == PLAYER_X 
                board[i][j] ← 'x'  
            ELSEIF grid[i][j] == PLAYER_O 
                board[i][j] ← 'o'  
            ENDIF
        ENDFOR
    ENDFOR

    print_tree(TDmodel, 2)
    dt_predict_best_move(TDmodel, board, PLAYER_O, &bestRow, &bestCol)

    DO
        row ← GetRandomValue(0, GRID_SIZE - 1)
        col ← GetRandomValue(0, GRID_SIZE - 1)
    WHILE (grid[row][col] != EMPTY)

    grid[bestRow][bestCol] ← PLAYER_O

    currentStats ← decisionTreeStats

    IF (CheckWin(PLAYER_O))
        gameOver ← true            
        winner ← PLAYER_O             
        gameState ← GAME_OVER          
        currentStats→aiWins ← currentStats→aiWins + 1       
        currentStats→totalGames ← currentStats→totalGames + 1   
        PlaySound(loseSound)      

    ELSE IF (CheckDraw())
        gameOver ← true               
        gameState ← GAME_OVER        
        winner ← EMPTY                
        currentStats→draws ← currentStats→draws + 1        
        currentStats→totalGames ← currentStats→totalGames + 1   
        PlaySound(drawSound)     
    ELSE
        currentPlayerTurn ← PLAYER_X_TURN
    ENDIF
ENDFUNCTION


/*********************/
/* Check.c file      */
/*********************/
FUNCTION CheckWin(player)
    FOR i = 0 to GRID_SIZE - 1 do
        IF (grid[i][0] == player && grid[i][1] == player && grid[i][2] == player)
            winningCells[0][0] ← i
            winningCells[0][1] ← 0
            winningCells[1][0] ← i
            winningCells[1][1] ← 1
            winningCells[2][0] ← i
            winningCells[2][1] ← 2
            return true
        ENDIF
    ENDFOR
    FOR i = 0 to GRID_SIZE -1 do
        IF (grid[0][i] == player && grid[1][i] == player && grid[2][i] == player)
            winningCells[0][0] ← 0
            winningCells[0][1] ← i
            winningCells[1][0] ← 1
            winningCells[1][1] ← i
            winningCells[2][0] ← 2
            winningCells[2][1] ← i
            return true
        ENDIF
    ENDFOR

    IF (grid[0][0] == player && grid[1][1] == player && grid[2][2] == player)
        winningCells[0][0] ← 0
        winningCells[0][1] ← 0
        winningCells[1][0] ← 1
        winningCells[1][1] ← 1
        winningCells[2][0] ← 2
        winningCells[2][1] ← 2
        return true
    ENDIF
    IF (grid[0][2] == player && grid[1][1] == player && grid[2][0] == player)
        winningCells[0][0] ← 0
        winningCells[0][1] ← 2
        winningCells[1][0] ← 1
        winningCells[1][1] ← 1
        winningCells[2][0] ← 2
        winningCells[2][1] ← 0
        return true
    ENDIF
    return false
ENDFUNCTION

FUNCTION CheckDraw()
    FOR i = 0 to GRID_SIZE - 1 do
        FOR j = 0 to GRID_SIZE - 1 do
            IF (grid[i][j] == EMPTY)
                return false
            ENDIF
        ENDFOR
    ENDFOR
    return true
ENDFUNCTION


/*********************/
/* Hint.c file       */
/*********************/
FUNCTION clearHint()
    hint.row ← -1
    hint.col ← -1 
ENDFUNCTION

FUNCTION getHint()
    bestScore ← -1000
    bestRow ← -1
    bestCol ← -1
    depthLimit ← 9
    FOR i=0 to GRID_SIZE -1 do
        FOR j = 0 to GRID_SIZE -1 do
            IF (grid[i][j] == EMPTY)
                grid[i][j] ← PLAYER_O
                socre ← Minimax(grid, false, 0, depthLimit, -1000, 1000)
                grid[i][j] ← EMPTY
                IF (score > bestScore)
                    bestScore ← score
                    bestRow ← i
                    bestCol ← j
                ENDIF
            ENDIF
        ENDFOR
    ENDFOR
    IF (bestRow != -1 && bestCol != -1)
        hint.row ← bestRow
        hint.col ← bestCol
    ENDIF
ENDFUNCTION


/*********************/
/* Minimax.c file    */
/*********************/
FUNCTION Minimax(board, isMaximizing, depth, depthLimit, alpha, beta)
    IF (depth >= depthLimit) 
        return 0
    ENDIF
    score ← EvaluateBoard(board)
    IF (score == 10) 
        return score - depth
    ENDIF
    IF (sore == -10)
        return score + depth
    ENDIF
    IF (CheckDraw())
        return 0
    ENDIF
    IF (isMaximizing)
        bestScore ← -1000
        FOR i = 0 to GRID_SIZE - 1 do
            FOR j = 0 to GRID_SIZE -1 do
                IF (board[i][j] == EMPTY)
                    board[i][j] ← PLAYER_O
                    bestScore ← fmax(bestScore, Minimax(board, false, depth + 1, depthLimit, alpha, beta))
                    board[i][j] ← EMPTY
                    alpha ← fmax(alpha, bestScore)
                    IF (beta <= alpha)
                        BREAK
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR
        return bestScore
    ELSE
        bestScore ← 1000
        FOR i = 0 to GRID_SIZE - 1 do
            FOR j = 0 to GRID_SIZE - 1 do
                IF (board[i][j] == EMPTY)
                    board[i][j] ← PLAYER_X
                    bestScore ← fmin(bestScore, Minimax(board, true, depth + 1, depthLimit, alpha, beta))
                    board[i][j] ← EMPTY
                    beta ← fmin(beta, bestScore)
                    IF (beta <= alpha)
                        BREAK
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR
        return bestScore
    ENDIF
ENDFUNCTION

FUNCTION EvaluateBoard(board)
    FOR row = 0 to GRID_SIZE - 1 do
        IF (board[row][0] == board[row][1] && board[row][0] == board[row][2])
            IF (board[row][0] == PLAYER_O)
                return 10
            ELSEIF (board[row][0] == PLAYER_X)
                return -10
            ENDIF
        ENDIF
    ENDFOR
    FOR col = 0 to GRID_SIZE - 1 do
        IF (board[0][col] == board[1][col] && board[0][col] == board[2][col])
            IF (board[0][col] == PLAYER_O)
                return 10
            ELSEIF (board[0][col] == PLAYER_X)
                return -10
            ENDIF
        ENDIF
    ENDFOR

    IF (board[0][0] == board[1][1] && board[0][0] == board[2][2])
        IF (board[0][0] == PLAYER_O)
            return 10
        ELSEIF (board[0][0] == PLAYER_X)
            return -10
        ENDIF
    ENDIF
    IF (board[0][2] == board[1][1] && board[0][2] == board[2][0])
        IF (board[0][2] == PLAYER_O)
            return 10
        ELSEIF (board[0][2] == PLAYER_X)
            return -10
        ENDIF
    ENDIF
    return 0
ENDFUNCTION


/**************************/
/* data_processing.c file */
/**************************/
FUNCTION load_data(filename, boards, outcomes, total_records)
    file_ptr refToFile → &filename
    total_records refToInt → &total_records

    OPEN FILE file_ptr
    IF (file_ptr = NULL)
        PRINT "Failed to open file"
    ENDIF

    WHILE (READ FILE *file_ptr)
        line[50] ← *file_ptr
        board[10] ← {line[0] to line[9]}
        outcome[10] ← {line[10] to line[19]}

        boards[total_records] ← board[10]
        outcomes[total_records] ← outcome_index(outcome)
        total_records ← total_records + 1
    ENDWHILE
    CLOSE FILE file_ptr
ENDFUNCTION

FUNCTION split_data(boards, outcomes, total_records, train_boards, train_outcomes, test_boards, test_outcomes, train_size, test_size, ratio)
    train_size refToInt → &train_size
    test_size refToInt → &test_size

    FOR i = (total_records - 1) down to 1 do
        j ← rand() % (i + 1)

        temp_board ← boards[i]
        boards[i] ← boards[j]
        boards[j] ← temp_board

        temp_outcome ← outcomes[i]
        outcomes[i] ← outcomes[j]
        outcomes[j] ← temp_outcome
    ENDFOR

    target_train_size ← ratio * total_records

    FOR i = 0 to total_records do
        IF (*train_sisze < target_train_size)
            train_boards[*train_size] ← boards[i]
            train_outcomes{*train_size} ← outcomes[i]
            *train_size ← *train_size + 1
        ELSE
            test_boards[*test_size] ← boards[i]
            test_outcomes{*test_size} ← outcomes[i]
            *test_size ← *test_size + 1
        ENDIF
    ENDFOR

    PRINT "train_boards array:"
    FOR i = 0 to 10 do
        PRINT train_boards[i]
    ENDFOR

    PRINT "train_outcomes array:"
    FOR i = 0 to 10 do
        PRINT train_outcomes[i]
    ENDFOR
ENDFUNCTION

FUNCTION outcome_index(outcome)
    IF (outcome = "positive")
        return POSITIVE
    ELSE
        return NEGATIVE
    ENDIF
ENDFUNCTION



/************************/
/* NBmodel.c file       */
/************************/
FUNCTION train_NBmodel(model, boards, outcomes, size)
    model refToNaiveBayesModel → &NBmodel

    positive_count ← 0
    negative_count ← 0

    x_counts[NUM_POSITIONS][NUM_OUTCOMES] ← {0}
    o_counts[NUM_POSITIONS][NUM_OUTCOMES] ← {0}
    b_counts[NUM_POSITIONS][NUM_OUTCOMES] ← {0}

    FOR i = 0 to size do
        outcome_idx ← outcomes[i]
        IF (outcome_idx = POSITIVE)
            positive_count ← positive_count + 1
        ELSE
            negative_count ← negative_count + 1
        ENDIF

        FOR j = 0 to NUM_POSITIONS do
            IF (boards[i][j] = 'x')
                x_counts[j][outcome_idx] ← x_counts[j][outcome_idx] + 1
            ELSEIF (boards[i][j] = 'o')
                o_counts[j][outcome_idx] ← o_counts[j][outcome_idx] + 1
            ELSE
                b_counts[j][outcome_idx] ← b_counts[j][outcome_idx] + 1
            ENDIF
        ENDFOR
    ENDFOR

    PRINT "X_counts array"
    PRINT " pos     neg"
    FOR i = 0 to NUM_POSITIONS do
        PRINT "Position (i+1) ["
        FOR j = 0 to NUM_OUTCOMES do
            PRINT x_counts[i][j]
        ENDFOR
        PRINT "]"
    ENDFOR

    PRINT "o_counts array"
    PRINT " pos     neg"
    FOR i = 0 to NUM_POSITIONS do
        PRINT "Position (i+1) ["
        FOR j = 0 to NUM_OUTCOMES do
            PRINT o_counts[i][j]
        ENDFOR
        PRINT "]"
    ENDFOR

    PRINT "b_counts array"
    PRINT " pos     neg"
    FOR i = 0 to NUM_POSITIONS do
        PRINT "Position (i+1) ["
        FOR j = 0 to NUM_OUTCOMES do
            PRINT b_counts[i][j]
        ENDFOR
        PRINT "]"
    ENDFOR

    model→class_probs[POSITIVE] ← positive_count / size
    model→class_probs[NEGATIVE] ← negative_count / size

    FOR i = 0 to NUM_POSITIONS do
        model→ x_probs[i][POSITIVE] ← (x_counts[i][POSITIVE] + 1) / (positive_count + 3)
        model→ x_probs[i][NEGATIVE] ← (x_counts[i][NEGATIVE] + 1) / (negative_count + 3)

        model→ o_probs[i][POSITIVE] ← (o_counts[i][POSITIVE] + 1) / (positive_count + 3)
        model→ o_probs[i][NEGATIVE] ← (o_counts[i][NEGATIVE] + 1) / (negative_count + 3)

        model→ b_probs[i][POSITIVE] ← (b_counts[i][POSITIVE] + 1) / (positive_count + 3)
        model→ b_probs[i][NEGATIVE] ← (b_counts[i][NEGATIVE] + 1) / (negative_count + 3)
    ENDFOR
ENDFUNCTION

FUNCTION save_NBmodel(model, filename)
    model refToNaiveBayesModel → &NBmodel

    file_ptr refToFile → &filename
    OPEN FILE file_ptr
    IF (file_ptr = NULL)
        PRINT "Failed to open file"
    ENDIF

    WRITE "Class Probabilities"
    WRITE "P(Positive):", model→class_probs[POSITIVE]
    WRITE "P(Negative):", model→class_probs[negative]
    
    FOR i = 0 to NUM_POSITIONS do
        WRITE "Position " (i+1)
        WRITE "P(x | Positive):", model→x_probs[i][POSITIVE]
        WRITE "P(x | Negative):", model→x_probs[i][NEGATIVE]
        WRITE "P(o | Positive):", model→o_probs[i][POSITIVE]
        WRITE "P(o | Negative):", model→o_probs[i][NEGATIVE]
        WRITE "P(b | Positive):", model→b_probs[i][POSITIVE]
        WRITE "P(b | Negative):", model→b_probs[i][NEGATIVE]
    ENDFOR

    CLOSE FILE file_ptr

    PRINT "Model weights saved to " filename
ENDFUNCTION

FUNCTION test_NBmodel(filename, mode, type, model, boards, outcomes, size)
    file_ptr refToFile → &filename
    model refToNaiveBayesModel → &NBmodel

    true_positive ← 0
    false_positive ← 0
    true_negative ← 0
    false_negative ← 0
    error_count ← 0

    FOR i = 0 to size do
        predicted_outcome ← predict_outcome(model, boards[i])
        IF (outcomes[i] = POSITIVE && predicted_outcome = POSITIVE)
            true_positive ← true_positive + 1
        ELSEIF (outcomes[i] = POSITIVE && predicted_outcome = NEGATIVE)
            false_negative ← false_negative + 1
            error_count ← error_count + 1
        ELSEIF (outcomes[i] = NEGATIVE && predicted_outcome = NEGATIVE)
            true_negative ← true_negative + 1
        ELSE
            false_positive ← false_positive + 1
            error_count ← error_count + 1
        ENDIF
    ENDFOR

    prob_of_error ← error_count / size * 100

    OPEN FILE file_ptr
    IF (file_ptr = NULL)
        PRINT "Failed to open file"
    ENDIF

    IF (type = "Testing)
        WRITE "\n\n"
    ENDIF

    WRITE "Dataset:", type
    WRITE "Accuracy:", (100 - prob_of_error), (size - error_count), size
    WRITE "Error:", prob_of_error, error_count, size
    WRITE "Confusion Matrix"
    WRITE "True Positive:", true_positive
    WRITE "False Positive:", false_positive
    WRITE "True Negative:", true_negative
    WRITE "False Negative:", false_negative

    CLOSE FILE file_ptr
ENDFUNCTION

FUNCTION calculate_probability(model, board, outcome)
    model refToNaiveBayesModel → &NBmodel

    probability ← model→class_probs[outcome]

    FOR i = 0 to NUM_POSITIONS do
        IF (board[i] = 'x')
            probability ← probability * model→x_probs[i][outcome]
        ELSEIF (board[i] = 'o')
            probability ← probability * model→o_probs[i][outcome]
        ELSE
            probability ← probability * model→b_probs[i][outcome]
        ENDIF
    ENDFOR
    return probability
ENDFUNCTION

FUNCTION predict_outcome(model, board)
    model refToNaiveBayesModel → &NBmodel

    positive_prob ← calculate_probability(model, board, POSITIVE)
    negative_prob ← calculate_probability(model, board, NEGATIVE)

    IF (positive_prob > negative_prob)
        return POSITIVE
    ELSE
        return NEGATIVE
    ENDIF
ENDFUNCTION

FUNCTION predict_move(model, grid[GRID_SIZE][GRID_SIZE], bestRow, bestCol)
    model refToNaiveBayesModel → &NBmodel
    bestRow refToInt → &bestRow
    bestCol refToInt → &bestCol

    best_move ← -1
    best_prob ← 0.0
    k ← 0

    PRINT "AI's Turn"
    PRINT "Game board layout as grid(array) format:"

    FOR i = 0 to GRID_SIZE do
        PRINT "["
        FOR j = 0 to GRID_SIZE do
            IF (grid[i][j] = EMPTY)
                board[k] ← 'b'
                PRINT "b"
            ELSEIF (grid[i][j] = PLAYER_O)
                board[k] ← 'o'
                PRINT "o"
            ELSE
                board[k] ← 'x'
                PRINT "x"
            ENDIF
            k ← k + 1
        ENDFOR
        PRINT "]"
    ENDFOR

    PRINT "Game board layout as string:"
    PRINT board

    PRINT "Simulated move       Simulated board       Posterior Probabilities"

    FOR i = 0 to NUM_POSITIONS do
        IF (board[i] = 'b')
            temp_board ← board
            temp_board[i] ← 'x'

            positive_prob ← calculate_probability(model, temp_board, POSITIVE)

            IF (positive_prob > best_prob)
                best_prob ← positive_prob
                best_move ← i
            ENDIF

            PRINT i, temp_board, positive_prob
        ENDIF
    ENDFOR

    divide(best_move, 3, bestRow, bestCol)

    PRINT "Best move: %best_move -> (%bestRow, %bestCol)"

    return 0
ENDFUNCTION

FUNCTION divide(dividend, divisor, quo, rem)
    quo refToInt → &quo
    rem refToInt → &rem

    *quo ← dividend / divisor
    *rem ← dividend % divisor
ENDFUNCTION
