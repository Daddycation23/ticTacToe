BEGIN 
    InitWindow()
    InitAudioDevice()
    icon ← LoadImage("assets\icon.png")
    SetWindowIcon(icon)
    UnloadImage(icon)

    buttonClickSound ← LoadSound("assets\ButtonClicked.mp3")
    popSound ← LoadSound("assets\Pop.mp3")
    victorySound ← LoadSound("assets\FFVictory.mp3")
    loseSound ← LoadSound("assets\MarioLose/mp3")
    drawSound ← LoadSound("assets\Draw.mp3")
    mainMenuSound ← LoadSound("assets\MainMenu.mp3")
    playSound ← LoadSound("assets\Play.mp3")

    InitSymbols()
    InitTitleWords()

    WHILE (!WindowShouldClose())
        IF (gameState == MENU || gameState == DIFFICULTY_SELECT || gameState == MODEL_SELECT)
            IF (!IsSoundPlaying(mainMenuSound))
                PlaySound(mainMenuSound)
            ENDIF
            StopSound(playSound)
        ELSEIF (gameState == GAME)
            IF (!IsSoundPlaying(playSound))
                PlaySound(playSound)
            ENDIF
            StopSound(mainMenuSound)
        ELSE 
            StopSound(mainMenuSound)
            StopSound(playSound)
        ENDIF

        IF (gameState == MENU || gameState == DIFFICULTY_SELECT || gameState == MODEL_SELECT)
            UpdateSymbols()
            UpdateTitleWords()
        ENDIF

        IF (gameState == MENU)
            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos ← GetMousePosition()

                IF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                    mousePos.y >= SCREEN_HEIGHT/2 + 60 && mousePos.y <= SCREEN_HEIGHT/2 + 100)
                    PlaySound(buttonClickSound)
                    isTwoPlayer ← false
                    gameState ← DIFFICULTY_SELECT
                ELSEIF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                    mousePos.y >= SCREEN_HEIGHT/2 + 120 && mousePos.y <= SCREEN_HEIGHT/2 + 160)
                    PlaySound(buttonClickSound)
                    isTwoPlayer ← true
                    gameState ← GAME
                    InitGame()
                ELSEIF (mousePos.x >= SCREEN_WIDTH/2 - 100 && mousePos.x <= SCREEN_WIDTH/2 + 100 &&
                        mousePos.y >= SCREEN_HEIGHT/2 + 180 && mousePos.y <= SCREEN_HEIGHT/2 + 220)
                        PlaySound(buttonClickSound)
                        BREAK
                ENDIF
            ENDIF
        ELSEIF (gameState == GAME)
            UpdateGame(buttonClickSound, popSound, victorySound, loseSound, drawSound)
        ELSEIF (gameState == GAME_OVER)
            UpdateGameOver(buttonClickSound)
        ELSEIF (gameState == DIFFICULTY_SELECT)

            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos ← GetMousePosition()

                IF (mousePos.x >= 20 && mousePos.x <= SCREEN_WIDTH/6 && mousePos.y >= 10 && mousePos.y <= 40)
                    PlaySound(buttonClickSound)
                    gameState ← MENU
                ENDIF

                IF (mousePos.x >= SCREEN_WIDTH/2 - BUTTON_WIDTH/2 && 
                    mousePos.x <= SCREEN_WIDTH/2 + BUTTON_WIDTH/2)

                    IF (mousePos.y >= SCREEN_HEIGHT/2 && mousePos.y <= SCREEN_HEIGHT/2 + BUTTON_HEIGHT)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← EASY
                        gameState ← MODEL_SELECT
                        InitGame()
                    ELSEIF (mousePos.y >= SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20 && 
                            mousePos.y <= SCREEN_HEIGHT/2 + BUTTON_HEIGHT * 2 + 20)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← MEDIUM
                        gameState ← GAME
                        InitGame()
                    ELSEIF (mousePos.y >= SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2 && 
                            mousePos.y <= SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2 + BUTTON_HEIGHT)
                        PlaySound(buttonClickSound)
                        currentDifficulty ← HARD
                        gameState ← GAME
                        InitGame()
                    ENDIF
                ENDIF
            ENDIF
        ELSEIF (gameState == MODEL_SELECT)
            IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
                mousePos ← GetMousePosition()

                IF (mousePos.x >= 20 && mousePos.x <= SCREEN_WIDTH/6 && mousePos.y >= 10 && mousePos.y <= 40)
                    PlaySound(buttonClickSound)
                    gameState ← DIFFICULTY_SELECT
                ENDIF

                nbBtn = SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
                        SCREEN_HEIGHT/2,
                        BUTTON_WIDTH,
                        BUTTON_HEIGHT

                dtBtn = SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
                        SCREEN_HEIGHT/2,
                        BUTTON_WIDTH,
                        BUTTON_HEIGHT

                IF (CheckCollisionPointRec(mousePos, nbBtn))
                    PlaySound(buttonClickSound)
                    currentModel ← NAIVE_BAYES
                    gameState ← GAME
                    InitGame()
                ELSEIF (CheckCollisionPointRec(mousePos, dtBtn))
                    PlaySound(buttonClickSound)
                    currentModel ← DECISION_TREE
                    gameState ← GAME
                    InitGame()
                ENDIF
            ENDIF
        ENDIF

        BeginDrawing()
        ClearBackground(RAYWHITE)

        SWITCH(gameState)
            CASE MENU
                DrawSymbols() 
                DrawTitleWords()
                DrawMenu()
            BREAK 
            CASE DIFFICULTY_SELECT
                DrawSymbols()
                DrawDifficultySelect()
            BREAK 
            CASE MODEL_SELECT
                DrawSymbols()
                DrawModelSelect()
            BREAK
            CASE GAME
                DrawGame()
            BREAK 
            CASE GAME_OVER
                DrawGame()
                DrawGameOver()
            BREAK 
        ENDSWITCH
        EndDrawing()
    ENDWHILE

    UnloadSound(buttonClickSound)
    UnloadSound(popSound)
    UnloadSound(victorySound)
    UnloadSound(loseSound)
    UnloadSound(drawSound)
    UnloadSound(mainMenuSound)
    UnloadSound(playSound)
    CloseAudioDevice()
    CloseWindow()
    return 0
END 

FUNCTION InitTitleWords()
    words ← {"Tic", "-", "Tac", "-", "Toe"}
    startX ← SCREEN_WIDTH / 2 - MeasureText("Tic-Tac-Toe", 40) / 2
    startY ← SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20
    int spacing ← 10

    FOR i ← 0 to 4 do
        titleWords[i].word ← words[i]
        titleWords[i].position ← (Vector2){ startX, startY }
        titleWords[i].targetPosition ← (Vector2){ startX, startY - 20 }
        titleWords[i].isJumping ← false
        titleWords[i].jumpSpeed ← JUMP_SPEED
        startX ← startX + MeasureText(words[i], 40) + spacing
    ENDFOR
ENDFUNCTION

FUNCTION InitSymbols()
    FOR i = 0 to MAX_SYMBOLS - 1 do
        symbols[i].position ← (Vector2){ GetRandomValue(0, SCREEN_WIDTH), GetRandomValue(-SCREEN_HEIGHT, 0) }
        symbols[i].symbol ← GetRandomValue(0, 1) ? 'X' : 'O'
        symbols[i].rotation ← GetRandomValue(0, 360)
    ENDFOR
ENDFUNCTION

FUNCTION UpdateTitleWords()
    currentWord ← 0
    jumpDelay ← 0.0f

    jumpDelay ← jumpDelay + GetFrameTime()
    IF (jumpDelay > JUMP_DELAY)
        IF (!titleWords[currentWord].isJumping)
            titleWords[currentWord].isJumping ← true
            jumpDelay ← 0.0f
        ENDIF
    ENDIF

    FOR i = 0 to 4 do 
        IF (titleWords[i].isJumping)
            titleWords[i].position.y ← titleWords[i].position.y - titleWords[i].jumpSpeed
            
            IF (titleWords[i].position.y <= titleWords[i].targetPosition.y)
                titleWords[i].jumpSpeed ← -titleWords[i].jumpSpeed
            ENDIF

            IF (titleWords[i].position.y >= SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20)
                titleWords[i].position.y ← SCREEN_HEIGHT / 5 + TITLE_GRID_SIZE * 50 + 20
                titleWords[i].isJumping ← false
                titleWords[i].jumpSpeed ← JUMP_SPEED
                currentWord ← (currentWord + 1) % 5
            ENDIF
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION UpdateSymbols()
    FOR i = 0 to MAX_SYMBOLS - 1 do 
        symbols[i].position.y ← symbols[i].position.y + SYMBOL_SPEED
        symbols[i].rotation ← symbols[i].rotation + ROTATION_SPEED
        IF (symbols[i].position.y > SCREEN_HEIGHT)
            symbols[i].position.y ← GetRandomValue(-SCREEN_HEIGHT, 0)
            symbols[i].position.x ← GetRandomValue(0, SCREEN_WIDTH)
            symbols[i].symbol ← IF GetRandomValue(0, 1) ? 'X' : 'O'
            symbols[i].rotation ← GetRandomValue(0, 360)
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION DrawTitleWords()
    FOR i = 0 to 4 do
        DrawText(titleWords[i].word, titleWords[i].position.x, titleWords[i].position.y, 40, BLACK)
    ENDFOR
ENDFUNCTION

FUNCTION DrawSymbols()
    FOR i = 0 tp MAX_SYMBOLS - 1 do
        origin ← {10, 10};  
        DrawTextPro(GetFontDefault(), &symbols[i].symbol, symbols[i].position, origin, symbols[i].rotation, 20, 1, symbols[i].symbol == 'X' ? BLUE : RED)
    ENDFOR
ENDFUNCTION

FUNCTION DrawGame()
    mousePos ← GetMousePosition()
    isHintHovered ← (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 && mousePos.y >= 10 && mousePos.y <= 40)
    isQuitHovered ← (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 && mousePos.y >= 10 && mousePos.y <= 40)

    IF (!gameOver && isQuitHovered)
        SetMouseCursor(MOUSE_CURSOR_POINTING_HAND)
    ELSEIF (!gameOver && isHintHovered)
        SetMouseCursor(MOUSE_CURSOR_POINTING_HAND)
    ELSEIF (!gameOver)
        SetMouseCursor(MOUSE_CURSOR_DEFAULT)
    ENDIF

    FOR i = 0 to GRID_SIZE - 1 do
        FOR j = 0 to GRID_SIZE - 1
            cell ← {(j * CELL_SIZE), (i * CELL_SIZE), CELL_SIZE, CELL_SIZE}
            isWinningCell ← false
            IF (gameOver && winner != EMPTY)
                FOR k = 0 to 2 do  
                    IF (winningCells[k][0] == i && winningCells[k][1] == j)
                        isWinningCell ← true
                        BREAK
                    ENDIF
                ENDFOR
            ENDIF

            isHovered ← !gameOver && grid[i][j] == EMPTY && CheckCollisionPointRec(mousePos, cell)

            IF (isWinningCell)
                IF (!isTwoPlayer && winner == PLAYER_O)
                    cellColor ← (Color){255, 200, 200, 255}
                ELSE
                    cellColor ← (Color){144, 238, 144, 255}
                ENDIF
            ELSE
                cellColor ← isHovered ? DARKGRAY : LIGHTGRAY
            ENDIF

            DrawRectangleRec(cell, isHovered ? DARKGRAY : LIGHTGRAY)

            IF (grid[i][j] == PLAYER_X)
                text ← "X"
                fontSize ← 100
                textWidth ← MeasureText(text, fontSize)
                textHeight ← fontSize * 0.75f
                textX ← cell.x + (CELL_SIZE - textWidth) / 2
                textY ← cell.y + (CELL_SIZE - textHeight) / 2
                DrawText(text, textX, textY, fontSize, BLUE)
            ELSEIF
                text ← "O"
                fontSize ← 100
                textWidth ← MeasureText(text, fontSize)
                textHeight ← fontSize * 0.75f
                textX ← cell.x + (CELL_SIZE - textWidth) / 2
                textY ← cell.y + (CELL_SIZE - textHeight) / 2
                DrawText(text, textX, textY, fontSize, RED)
            ENDIF
        ENDFOR
    ENDFOR

    FOR int = 1 to GRID_SIZE - 1 do 
        DrawLine(i * CELL_SIZE, 0, i * CELL_SIZE, SCREEN_HEIGHT, BLACK)
        DrawLine(0, i * CELL_SIZE, SCREEN_WIDTH, i * CELL_SIZE, BLACK)
    ENDFOR

    hintBtn ← {SCREEN_WIDTH - 80, 10, 70, 30}
    DrawButton(hintBtn, "Hint", 20, !gameOver && isHintHovered)
    quitBtn ← {SCREEN_WIDTH - 80, 10, 70, 30}
    DrawButton(quitBtn, "Quit", 20, !gameOver && isQuitHovered)

    IF (!gameOver)
        IF (!isTwoPlayer)
            currentStats ← GetCurrentModeStats()

            PRINT (statsText, "Player: %d | AI: %d | Draws: %d", 
                    currentStats->playerWins, 
                    currentStats->aiWins, 
                    currentStats->draws)
            
            DrawText(statsText, SCREEN_WIDTH/2 - MeasureText(statsText, 20)/2, 10, 20, BLACK)
        ENDIF

        yPos ← isTwoPlayer ? 20 : 40
        IF (currentPlayerTurn == PLAYER_X_TURN)
            turnText ← "Player X's Turn"
            DrawText(turnText, SCREEN_WIDTH/2 - MeasureText(turnText, 30)/2, yPos, 30, BLUE)
        ELSE
            turnText ← "Player O's Turn"
            DrawText(turnText, SCREEN_WIDTH/2 - MeasureText(turnText, 30)/2, yPos, 30, RED)
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION DrawMenu()
    titleFontSize ← 40
    buttonFontSize ← 20 
    cellSize ← 50;  // larger cells for better visibility
    gridWidth ← TITLE_GRID_SIZE * cellSize
    gridHeight ← TITLE_GRID_SIZE * cellSize
    startX ← SCREEN_WIDTH/2 - gridWidth/2
    startY ← SCREEN_HEIGHT/5

    FOR i = 0 to TITLE_GRID_SIZE - 1 do
        FOR j = 0 to TITLE_GRID_SIZE - 1 do
            cell = {
                startX + j * cellSize,
                startY + i * cellSize,
                cellSize,
                cellSize
            }
            DrawRectangleLinesEx(cell, 2, BLACK)

            IF (!titleSymbols[i][j].active && GetRandomValue(0, 100) < 2)
                titleSymbols[i][j].symbol ← GetRandomValue(0, 1) ? 'X' : 'O'
                titleSymbols[i][j].alpha ← 0
                titleSymbols[i][j].active ← true
            ENDIF

            IF (titleSymbols[i][j].active)
                titleSymbols[i][j].alpha ← titleSymbols[i][j].alpha + GetFrameTime() * 2
                IF (titleSymbols[i][j].alpha > 1.0f) 
                    titleSymbols[i][j].alpha ← 0
                    titleSymbols[i][j].active ← false
                ENDIF

                symbolColor ← titleSymbols[i][j].symbol == 'X' ? BLUE : RED
                symbolColor.a ← (titleSymbols[i][j].alpha * 255)

                textPos ← {
                    cell.x + (cellSize - MeasureText(&titleSymbols[i][j].symbol, 40))/2,
                    cell.y + (cellSize - 40)/2
                }
                DrawText(&titleSymbols[i][j].symbol, textPos.x, textPos.y, 40, symbolColor)
            ENDIF
        ENDFOR
    ENDFOR

    singlePlayerBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    twoPlayerBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    exitBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 3,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    mousePos ← GetMousePosition()
    singlePlayerHover ← CheckCollisionPointRec(mousePos, singlePlayerBtn)
    twoPlayerHover ← CheckCollisionPointRec(mousePos, twoPlayerBtn)
    exitHover ← CheckCollisionPointRec(mousePos, exitBtn)
    DrawButton(singlePlayerBtn, "Single Player", buttonFontSize, singlePlayerHover)
    DrawButton(twoPlayerBtn, "Two Players", buttonFontSize, twoPlayerHover)
    DrawButton(exitBtn, "Exit", buttonFontSize, exitHover)
    SetMouseCursor((singlePlayerHover || twoPlayerHover || exitHover) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION DrawGameOver()
    titleFontSize ← 40
    buttonFontSize ← 20
    DrawRectangle(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, (Color){0, 0, 0, 100})

    IF (winner == PLAYER_X)
        resultText ← isTwoPlayer ? "Player X Wins!" : "You win!"
        resultColor ← BLUE

    ELSEIF (winner == PLAYER_O)
        resultText ← isTwoPlayer ? "Player O Wins!" : "You lose!"
        resultColor ← RED

    ELSE 
        resultText ← "It's a Draw!"
        resultColor ← DARKGRAY
    ENDIF

    textWidth ← MeasureText(resultText, titleFontSize)
    DrawRectangle(
        SCREEN_WIDTH/2 - textWidth/2 - 10,
        SCREEN_HEIGHT/3 - 10,
        textWidth + 20,
        titleFontSize + 20,
        WHITE
        )
    DrawText(
        resultText, 
        SCREEN_WIDTH/2 - textWidth/2,
        SCREEN_HEIGHT/3,
        titleFontSize,
        resultColor
        )
    retryBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + 40, 
        BUTTON_WIDTH,
        BUTTON_HEIGHT
        }
    menuBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + 100, 
        BUTTON_WIDTH,
        BUTTON_HEIGHT
        }
    mousePos ← GetMousePosition()
    isHoveringMenu ← CheckCollisionPointRec(mousePos, menuBtn)
    isHoveringRetry ← CheckCollisionPointRec(mousePos, retryBtn)
    DrawButton(retryBtn, "Retry", buttonFontSize, isHoveringRetry)
    DrawButton(menuBtn, "Back to Menu", buttonFontSize, isHoveringMenu)
    SetMouseCursor((isHoveringMenu || isHoveringRetry) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION DrawButton()
    vibrationBounds ← bounds

    IF (isHovered)
        buttonVibrationOffset ← sinf(GetTime() * vibrationSpeed) * vibrationAmount
        vibrationBounds.x ← vibrationBounds.x + buttonVibrationOffset
    ENDIF

    DrawRectangleRec(vibrationBounds, isHovered ? GRAY : LIGHTGRAY)
    DrawRectangleLinesEx(vibrationBounds, 2, BLACK)
    DrawText(
        text,
        vibrationBounds.x + (vibrationBounds.width - MeasureText(text, fontSize))/2, 
        vibrationBounds.y + (vibrationBounds.height - fontSize)/2, 
        fontSize,
        BLACK
    )
ENDFUNCTION

FUNCTION DrawDifficultySelect()
    titleFontSize ← 40
    buttonFontSize ← 20 
    title ← "Select Difficulty"
    DrawText(
        title, 
        SCREEN_WIDTH/2 - MeasureText(title, titleFontSize)/2, 
        SCREEN_HEIGHT/3,
        titleFontSize,
        BLACK
        )
    
    easyBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    mediumBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    hardBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + (BUTTON_HEIGHT + 20) * 2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }

    backBtn ← {
        20,                
        10,                 
        SCREEN_WIDTH/6,    
        30                 
    }

    mousePos ← GetMousePosition()
    easyHover ← CheckCollisionPointRec(mousePos, easyBtn)
    mediumHover ← CheckCollisionPointRec(mousePos, mediumBtn)
    hardHover ← CheckCollisionPointRec(mousePos, hardBtn)
    backHover ← CheckCollisionPointRec(mousePos, backBtn)
    DrawButton(easyBtn, "Easy", buttonFontSize, easyHover)
    DrawButton(mediumBtn, "Medium", buttonFontSize, mediumHover)
    DrawButton(hardBtn, "Hard", buttonFontSize, hardHover)
    DrawButton(backBtn, "Back", buttonFontSize, backHover)
    SetMouseCursor((easyHover || mediumHover || hardHover || backHover) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION DrawModelSelect()
    title ← "Select AI Model"
    DrawText(
        SCREEN_WIDTH/2 - MeasureText(title, 40)/2,
        SCREEN_HEIGHT/3,
        40,
        BLACK
    )
    nbBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }
    dtBtn ← {
        SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
        SCREEN_HEIGHT/2 + BUTTON_HEIGHT + 20,
        BUTTON_WIDTH,
        BUTTON_HEIGHT
    }
    backBtn ← {
        20,                
        10,                 
        SCREEN_WIDTH/6,    
        30                 
    }
    mousePos ← GetMousePosition();
    nbHover ← CheckCollisionPointRec(mousePos, nbBtn)
    dtHover ← CheckCollisionPointRec(mousePos, dtBtn)
    backHover ← CheckCollisionPointRec(mousePos, backBtn)
    DrawButton(nbBtn, "Naive Bayes", 20, nbHover)
    DrawButton(dtBtn, "Decision Tree", 20, dtHover)
    DrawButton(backBtn, "Back", 20, backHover)
    SetMouseCursor((nbHover || dtHover || backHover) ? MOUSE_CURSOR_POINTING_HAND : MOUSE_CURSOR_DEFAULT)
ENDFUNCTION

FUNCTION InitGame()
    StopSound(victorySound)
    StopSound(loseSound)
    StopSound(drawSound)
    memset(grid, EMPTY, sizeof(grid))
    gameOver ← false
    winner ← EMPTY
    currentPlayerTurn ← PLAYER_X_TURN
ENDFUNCTION

FUNCTION GetCurrentModeStats()
    IF (currentDifficulty == EASY)
        IF (currentModel == NAIVE_BAYES)
            RETURN &naiveBayesStats
        ELSE
            RETURN &decisionTreeStats
        ENDIF
    ELSE
        IF (currentDifficulty == MEDIUM)
            RETURN &mediumStats
        ELSE
            RETURN &hardStats
        ENDIF
    ENDIF
END FUNCTION

FUNCTION UpdateGame()
    IF (gameOver) RETURN 

    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        IF (mousePos.x >= SCREEN_WIDTH - 80 && mousePos.x <= SCREEN_WIDTH - 10 && mousePos.y >= 10 && mousePos.y <= 40)
            PlaySound(buttonClickSound)
            gameState ← MENU
            RETURN 
        ENDIF
    ENDIF

    IF (currentPlayerTurn == PLAYER_X_TURN)
        IF (HandlePlayerTurn())
            PlaySound()
        ENDIF
    
    ELSEIF (currentPlayerTurn == PLAYER_O_TURN)
        IF (isTwoPlayer)
            IF (HandlePlayerTurn()) 
                PlaySound() 
            ENDIF
        ELSE
            SWITCH(currentDifficulty)
                CASE EASY
                    IF (currentModel == NAIVE_BAYES)
                        AITurn()
                    ELSE
                        AITurnDecisionTree()
                    ENDIF
                BREAK
                
                CASE MEDIUM
                    AITurn()
                BREAK

                CASE HARD
                    AITurn()
                BREAK
            ENDSWITCH
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION HandlePlayerTurn()
    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        row ← (int)(mousePos.y / CELL_SIZE)
        col ← (int)(mousePos.x / CELL_SIZE)
        currentStats ← GetCurrentModeStats()

        IF (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE)
            IF (grid[row][col] == EMPTY)
                grid[row][col] ← (currentPlayerTurn == PLAYER_X_TURN) ? PLAYER_X : PLAYER_O
                IF (CheckWin(grid[row][col]))
                    gameOver ← true
                    winner ← grid[row][col]
                    gameState ← GAME_OVER

                    IF (!isTwoPlayer)
                        IF (winner == PLAYER_X)
                            currentStats → playerWins + 1
                            currentStats → totalGames + 1
                            PlaySound(victorySound)
                        ELSE
                            currentStats → aiWins + 1
                            currentStats → totalGames + 1
                            PlaySound(loseSound)
                        ENDIF
                    ELSE
                        PlaySound(victorySound)
                    ENDIF

                ELSEIF (CheckDraw())
                    gameOver ← true
                    gameState ← GAME_OVER
                    winner ← EMPTY
                    currentStats → draws + 1
                    currentStats → totalGames + 1
                    PlaySound(drawSound)

                ELSE 
                    currentPlayerTurn ← (currentPlayerTurn == PLAYER_X_TURN) ? PLAYER_O_TURN : PLAYER_X_TURN
                ENDIF

                RETURN true
            ENDIF
        ENDIF
    ENDIF
    RETURN false
ENDFUNCTION

FUNCTION AITurn()
    bestScore ← -1000
    bestRow ← -1
    bestCol ← -1
    IF (currentDifficulty == EASY)
        IF (currentModel == NAIVE_BAYES)
            predict_move()
        ELSE
            AITurnDecisionTree()
        ENDIF

    ELSEIF (currentDifficulty == MEDIUM)
        depthLimit ← 4
        FOR i = 0 to GRID_SIZE - 1 do
            FOR j = 0 to GRID_SIZE - 1 do
                IF (grid[i][j] == EMPTY)
                    grid[i][j] ← PLAYER_O
                    score ← MiniMax()
                    grid[i][j] ← EMPTY

                    IF (score > bestScore)
                        bestScore ← score
                        bestRow ← i 
                        bestCol ← j 
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR

    ELSEIF (currentDifficulty == HARD)
        depthLimit ← 9
        FOR i = 0 to GRID_SIZE - 1 do
            FOR j = 0 to GRID_SIZE - 1 do
                IF (grid[i][j] == EMPTY)
                    grid[i][j] ← PLAYER_O
                    score ← MiniMax()
                    grid[i][j] ← EMPTY

                    IF (score > bestScore)
                        bestScore ← score
                        bestRow ← i 
                        bestCol ← j 
                    ENDIF
                ENDIF
            ENDFOR
        ENDFOR
    ENDIF

    IF (bestRow != -1 && bestCol != -1)
        grid[bestRow][bestCol] ← PLAYER_O
    ENDIF

    currentStats ← GetCurrentModeStats()

    IF (CheckWin(PLAYER_O))
        gameOver ← true
        winner ← PLAYER_O
        gameState ← GAME_OVER
        currentStats → aiWins + 1
        currentStats → totalGames + 1
        IF (!isTwoPlayer)
            PlaySound(loseSound)
        ELSE
            PlaySound(victorySound)
        ENDIF
    ELSEIF (CheckDraw())
        gameOver ← true
        gameState ← GAME_OVER
        winner ← EMPTY
        currentStats → draws + 1
        currentStats → totalGames + 1
        PlaySound(drawSound)
    ELSE
        currentPlayerTurn ← PLAYER_X_TURN
    ENDIF
ENDFUNCTION

FUNCTION CheckWin()
    FOR i = 0 to GRID_SIZE - 1 do
        IF (grid[i][0] == player && grid[i][1] == player && grid[i][2] == player)
            RETURN true
        ENDIF
        IF (grid[0][i] == player && grid[1][i] == player && grid[2][i] == player)
            RETURN true
        ENDIF
    ENDFOR

    IF (grid[0][0] == player && grid[1][1] == player && grid[2][2] == player)
        RETURN true
    ENDIF
    IF (grid[0][2] == player && grid[1][1] == player && grid[2][0] == player)
        RETURN true
    ENDIF
    RETURN false
ENDFUNCTION

FUNCTION CheckDraw()
    FOR i = 0 to GRID_SIZE - 1 do
        FOR j = 0 to GRID_SIZE - 1 do
            IF (grid[i][j] == EMPTY)
                RETURN false
            ENDIF
        ENDFOR
    RETURN true
    ENDFOR
ENDFUNCTION

FUNCTION UpdateGameOver()
    IF (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
        mousePos ← GetMousePosition()
        retryBtn ← {
            SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
            SCREEN_HEIGHT/2 + 40,
            BUTTON_WIDTH,
            BUTTON_HEIGHT
        }
        menuBtn ← {
            SCREEN_WIDTH/2 - BUTTON_WIDTH/2,
            SCREEN_HEIGHT/2 + 100,
            BUTTON_WIDTH,
            BUTTON_HEIGHT
        }
        IF (CheckCollisionPointRec(mousePos, menuBtn))
            PlaySound(buttonClickSound)
            gameState ← MENU
            InitGame()
        ELSEIF (CheckCollisionPointRec(mousePos, retryBtn))
            PlaySound(buttonClickSound)
            gameState ← GAME
            InitGame()
        ENDIF
    ENDIF
ENDFUNCTION

FUNCTION EvaluateBoard()
    FOR row = 0 to GRID_SIZE - 1 do
        IF (board[row][0] == board[row][1] && board[row][0] == board[row][2])
            IF (board[row][0] == PLAYER_O)
                RETURN 10
            ELSEIF (board[row][0] == PLAYER_X)
                RETURN -10
            ENDIF
        ENDIF
    ENDFOR
    FOR col = 0 to GRID_SIZE - 1 do
        IF (board[0][col] == board[1][col] && board[0][col] == board[2][col])
            IF (board[0][col] == PLAYER_O)
                RETURN 10
            ELSEIF (board[0][col] == PLAYER_X)
                RETURN -10
            ENDIF
        ENDIF
    ENDFOR

    IF (board[0][0] == board[1][1] && board[0][0] == board[2][2])
        IF (board[0][0] == PLAYER_O)
            RETURN 10
        ELSEIF (board[0][0] == PLAYER_X)
            RETURN -10
        ENDIF
    ENDIF
    IF (board[0][2] == board[1][1] && board[0][2] == board[2][0])
        IF (board[0][2] == PLAYER_O)
            RETURN 10
        ELSEIF (board[0][2] == PLAYER_X)
            RETURN -10
        ENDIF
    ENDIF
    RETURN 0
ENDFUNCTION